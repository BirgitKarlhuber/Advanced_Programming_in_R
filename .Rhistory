# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > dist[short_index] + graph[short_index,i]){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
}
# Lastly, note that we are finished with this node.
visited[short_index] = TRUE
}
}
return(dist[short_index])
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
rm(list=ls())
library(markmyassignment)
lab_path <- "https://raw.githubusercontent.com/STIMALiU/AdvRCourse/master/Labs/Tests/lab2.yml"
set_assignment(lab_path)
source("2_week/Lab2_Birgit_Karlhuber.R")
mark_my_assignment("cov")
dijkstra <- function(graph, init_node){
stopifnot(is.data.frame(graph), length(graph)==3)
dist <- rep(Inf,nrow(graph))
prev <- rep(FALSE, nrow(graph))
dist[init_node] <- 0 # distance from the starting node to itself
repeat{
# find node with the currently shortest distance from the initial node
short_dist = Inf
short_index = -1
for(i in seq_along(dist)) {
if(dist[i] < short_dist && !prev[i]){
short_dist = dist[i]
short_index = i
}
}
if(short_dist == -1){
# There was no node not yet visited --> We are done
return (dist)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[short_index,])) {
# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > dist[short_index] + graph[short_index,i]){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
}
# Lastly, note that we are finished with this node.
visited[short_index] = TRUE
}
}
return(dist[short_index])
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init_node){
stopifnot(is.data.frame(graph), length(graph)==3)
dist <- rep(Inf,nrow(graph))
prev <- rep(FALSE, nrow(graph))
dist[init_node] <- 0 # distance from the starting node to itself
repeat{
# find node with the currently shortest distance from the initial node
short_dist = Inf
short_index = -1
for(i in seq_along(dist)) {
if(dist[i] < short_dist && !prev[i]){
short_dist = dist[i]
short_index = i
}
}
if(short_dist == -1){
# There was no node not yet visited --> We are done
return (dist)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[short_index,])) {
# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > dist[short_index] + graph[short_index,i]){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
}
# Lastly, note that we are finished with this node.
prev[short_index] = TRUE
}
}
return(dist[short_index])
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init_node){
stopifnot(is.data.frame(graph), length(graph)==3)
dist <- rep(Inf,nrow(graph))
prev <- rep(FALSE, nrow(graph))
dist[init_node] <- 0 # distance from the starting node to itself
repeat{
# find node with the currently shortest distance from the initial node
short_dist = Inf
short_index = -1
for(i in seq_along(dist)) {
if(dist[i] < short_dist && !prev[i]){
short_dist = dist[i]
short_index = i
}
}
if(short_dist == -1){
# There was no node not yet visited --> We are done
return (dist)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[short_index,])) {
# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > dist[short_index] + graph[short_index,i]){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
}
# Lastly, note that we are finished with this node.
prev[short_index] = TRUE
}
}
return(dist)
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init_node){
stopifnot(is.data.frame(graph), length(graph)==3)
dist <- rep(Inf,nrow(graph))
prev <- rep(FALSE, nrow(graph))
dist[init_node] <- 0 # distance from the starting node to itself
repeat{
# find node with the currently shortest distance from the initial node
short_dist = Inf
short_index = -1
for(i in seq_along(dist)) {
if(dist[i] < short_dist && !prev[i]){
short_dist = dist[i]
short_index = i
}
}
if(short_dist == -1){
# There was no node not yet visited --> We are done
return (dist)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[short_index,])) {
# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > dist[short_index] + graph[short_index,i]){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
cat("Updating distance of node ", i, " to ", distances[i], "\n")
}
# Lastly, note that we are finished with this node.
prev[short_index] = TRUE
cat("Visited nodes: ", visited, "\n")
cat("Currently lowest distances: ", distances, "\n")
}
}
# return(dist)
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init_node){
stopifnot(is.data.frame(graph), length(graph)==3)
dist <- rep(Inf,nrow(graph))
prev <- rep(FALSE, nrow(graph))
dist[init_node] <- 0 # distance from the starting node to itself
repeat{
# find node with the currently shortest distance from the initial node
short_dist = Inf
short_index = -1
for(i in seq_along(dist)) {
if(dist[i] < short_dist && !prev[i]){
short_dist = dist[i]
short_index = i
}
}
if(short_dist == -1){
# There was no node not yet visited --> We are done
return (dist)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[short_index,])) {
# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > dist[short_index] + graph[short_index,i]){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
cat("Updating distance of node ", i, " to ", dist[i], "\n")
}
# Lastly, note that we are finished with this node.
prev[short_index] = TRUE
cat("Visited nodes: ", prev, "\n")
cat("Currently lowest distances: ", dist, "\n")
}
}
# return(dist)
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init_node){
dijkstra <- function(graph, init_node){
stopifnot(is.data.frame(graph), length(graph)==3)
dist <- rep(Inf,nrow(graph))
prev <- rep(FALSE, nrow(graph))
dist[init_node] <- 0 # distance from the starting node to itself
repeat{
# find node with the currently shortest distance from the initial node
short_dist = Inf
short_index = -1
for(i in seq_along(dist)) {
if(dist[i] < short_dist && !prev[i]){
short_dist = dist[i]
short_index = i
}
}
if(short_dist == -1){
# There was no node not yet visited --> We are done
return (dist)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[short_index,])) {
# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > (dist[short_index] + graph[short_index,i])){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
}
# Lastly, note that we are finished with this node.
prev[short_index] = TRUE
}
}
# return(dist)
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init_node){
stopifnot(is.data.frame(graph), length(graph)==3)
dist <- rep(Inf,nrow(graph))
prev <- rep(FALSE, nrow(graph))
dist[init_node] <- 0 # distance from the starting node to itself
repeat{
# find node with the currently shortest distance from the initial node
short_dist <- Inf
short_index <- -1
for(i in seq_along(dist)) {
if(dist[i] < short_dist && !prev[i]){
short_dist <- dist[i]
short_index <- i
}
}
if(short_dist == -1){
# There was no node not yet visited --> We are done
return(dist)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[short_index,])) {
# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > dist[short_index] + graph[short_index,i]){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
}
# Lastly, note that we are finished with this node.
prev[short_index] = TRUE
}
}
# return(dist)
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init_node){
stopifnot(is.data.frame(graph), length(graph)==3)
dist <- rep(Inf,nrow(graph))
prev <- rep(FALSE, nrow(graph))
dist[init_node] <- 0 # distance from the starting node to itself
repeat{
# find node with the currently shortest distance from the initial node
short_dist <- Inf
short_index <- -1
for(i in seq_along(dist)) {
if(dist[i] < short_dist && !prev[i]){
short_dist <- dist[i]
short_index <- i
}
}
if(short_dist == -1){
# There was no node not yet visited --> We are done
return(dist)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[short_index,])) {
# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > dist[short_index] + graph[short_index,i]){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
cat("Updating distance of node ", i, " to ", distances[i], "\n")
}
# Lastly, note that we are finished with this node.
prev[short_index] = TRUE
cat("Visited nodes: ", visited, "\n")
cat("Currently lowest distances: ", distances, "\n")
}
}
# return(dist)
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init_node){
stopifnot(is.data.frame(graph), length(graph)==3)
dist <- rep(Inf,nrow(graph))
prev <- rep(FALSE, nrow(graph))
dist[init_node] <- 0 # distance from the starting node to itself
repeat{
# find node with the currently shortest distance from the initial node
short_dist <- Inf
short_index <- -1
for(i in seq_along(dist)) {
if(dist[i] < short_dist && !prev[i]){
short_dist <- dist[i]
short_index <- i
}
}
if(short_dist == -1){
# There was no node not yet visited --> We are done
return(dist)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[short_index,])) {
# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > dist[short_index] + graph[short_index,i]){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
cat("Updating distance of node ", i, " to ", dist[i], "\n")
}
# Lastly, note that we are finished with this node.
prev[short_index] = TRUE
cat("Visited nodes: ", prev, "\n")
cat("Currently lowest distances: ", dist, "\n")
}
}
# return(dist)
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init_node){
stopifnot(is.data.frame(graph), length(graph)==3)
dist <- rep(Inf,nrow(graph))
prev <- rep(FALSE, nrow(graph))
dist[init_node] <- 0 # distance from the starting node to itself
repeat{
# find node with the currently shortest distance from the initial node
short_dist <- Inf
short_index <- -1
for(i in seq_along(dist)) {
if(dist[i] < short_dist && !prev[i]){
short_dist <- dist[i]
short_index <- i
}
}
if(short_dist == -1){
# There was no node not yet visited --> We are done
return(dist)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[short_index,])) {
# ...if the path over this edge is shorter...
if(graph[short_index,i] != 0 && dist[i] > dist[short_index] + graph[short_index,i]){
# ...Save this path as new shortest path.
dist[i] = dist[short_index] + graph[short_index,i]
cat("Updating distance of node ", i, " to ", dist[i], "\n")
}
# Lastly, note that we are finished with this node.
prev[short_index] = TRUE
cat("Visited nodes: ", prev, "\n")
cat("Currently lowest distances: ", dist, "\n")
}
}
# return(dist)
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, start){
#' Implementation of dijkstra using adjacency matrix.
#' This returns an array containing the length of the shortest path from the start node to each other node.
#' It is only guaranteed to return correct results if there are no negative edges in the graph. Positive cycles are fine.
#' This has a runtime of O(|V|^2) (|V| = number of Nodes), for a faster implementation see @see ../fast/Dijkstra.java (using adjacency lists)
#' @param graph an adjacency-matrix-representation of the graph where (x,y) is the weight of the edge or 0 if there is no edge.
#' @param start the node to start from.
#' @return an array containing the shortest distances from the given start node to each other node
# This contains the distances from the start node to all other nodes
distances = rep(Inf, nrow(graph))
# This contains whether a node was already visited
visited = rep(FALSE, nrow(graph))
# The distance from the start node to itself is of course 0
distances[start] = 0
# While there are nodes left to visit...
repeat{
# ... find the node with the currently shortest distance from the start node...
shortest_distance = Inf
shortest_index = -1
for(i in seq_along(distances)) {
# ... by going through all nodes that haven't been visited yet
if(distances[i] < shortest_distance && !visited[i]){
shortest_distance = distances[i]
shortest_index = i
}
}
cat("Visiting node ", shortest_index, " with current distance ", shortest_distance, "\n")
if(shortest_index == -1){
# There was no node not yet visited --> We are done
return (distances)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[shortest_index,])) {
# ...if the path over this edge is shorter...
if(graph[shortest_index,i] != 0 && distances[i] > distances[shortest_index] + graph[shortest_index,i]){
# ...Save this path as new shortest path.
distances[i] = distances[shortest_index] + graph[shortest_index,i]
cat("Updating distance of node ", i, " to ", distances[i], "\n")
}
# Lastly, note that we are finished with this node.
visited[shortest_index] = TRUE
cat("Visited nodes: ", visited, "\n")
cat("Currently lowest distances: ", distances, "\n")
}
}
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
dijkstra <- function(graph, start){
# This contains the distances from the start node to all other nodes
distances = rep(Inf, nrow(graph))
# This contains whether a node was already visited
visited = rep(FALSE, nrow(graph))
# The distance from the start node to itself is of course 0
distances[start] = 0
# While there are nodes left to visit...
repeat{
# ... find the node with the currently shortest distance from the start node...
shortest_distance = Inf
shortest_index = -1
for(i in seq_along(distances)) {
# ... by going through all nodes that haven't been visited yet
if(distances[i] < shortest_distance && !visited[i]){
shortest_distance = distances[i]
shortest_index = i
}
}
cat("Visiting node ", shortest_index, " with current distance ", shortest_distance, "\n")
if(shortest_index == -1){
# There was no node not yet visited --> We are done
return (distances)
}
# ...then, for all neighboring nodes that haven't been visited yet....
for(i in seq_along(graph[shortest_index,])) {
# ...if the path over this edge is shorter...
if(graph[shortest_index,i] != 0 && distances[i] > distances[shortest_index] + graph[shortest_index,i]){
# ...Save this path as new shortest path.
distances[i] = distances[shortest_index] + graph[shortest_index,i]
cat("Updating distance of node ", i, " to ", distances[i], "\n")
}
# Lastly, note that we are finished with this node.
visited[shortest_index] = TRUE
cat("Visited nodes: ", visited, "\n")
cat("Currently lowest distances: ", distances, "\n")
}
}
}
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
graph <- wiki_graph
init_node <- 1
nodes_all <- unique(graph[2]) # get all unique nodes in the graph
short_dist <- rep(0,length(nodes_all))
nodes <- nodes_all[!nodes_all == init_node] # remove initial node
nodes
nodes
nodes <- order(nodes)
nodes
nodes_all
graph <- wiki_graph
graph
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
graph <- wiki_graph
graph
wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
graph <- wiki_graph
graph
